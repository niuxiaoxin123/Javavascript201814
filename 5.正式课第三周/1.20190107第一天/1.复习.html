<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div id="box" style="width: 100px;height:100px;background: red"></div>
<script>
    // 1. 变量提升   作用域    this   面向对象
    // 2. 原型深入   三种角色   call\apply\bind  商品排序（DOM的映射、回流）  类数组转数组  数据绑定  ajax

    //  面向对象： 单例模式  工厂模式  构造函数模式  原型模式
    // 单例模式---> 高级单例模式
    // 工厂模式 ： 函数的封装
    // 构造函数模式： new Fn；Fn 是一个类
    // 类：自定义类、内置类: 类一定是函数，但函数不一定是类
    // Number  String  Boolean  Null Undefined  Object  Function  RegExp  Date  Symbol ...
    //原型模式 ： 解决了属性的公有问题
    //console.log(Null);// Null和 Undefined是不允许在浏览器中被调用的；
   /* var utils = (function(){
        var  rr = 199;
        function f() {

        }
        function fn() {

        }
        return {
            f:f,
            fn:fn
        }
    })();*/
   // Array的实例: 通过new Array创建实例，如果只有一个参数数字，那么会作为数组的长度；那么超过1个参数，就会变成数组成员项；
   /*var  arr = [12,3,45,5];
   var  arr1 = [6,3,5,56];
   //var a = new Array(10,2);// [10,2]
    // 原型扩展1
    Array.prototype.pop = function () {
        console.log(100);
    }
    arr.pop();
    Array.prototype = {
        pop:function () {
            console.log(200);
        }
    }
    arr.pop()
    arr.hasOwnProperty()
    arr.apply(100);

    // 函数三种角色： 普通函数 、类、对象
    // call、apply、bind: 改变函数中this指向
    fn.call();*/// call改变fn中的this，fn是call中的this；call是改变this中的this；并且让this执行；
   /* function fn1() {
        console.log(1);
    }
    function fn2() {
        console.log(2);
    }
    fn1.call.call(fn2);*/// fn.call--> A  A.call(fn2)   A 中的this改变成fn2; 让fn1.call执行，fn1.call 中this-->fn2； fn2执行；
    // 严格模式
    // 在严格模式下，给call传入undefined或null，那么函数中的this就指向对应的参数；在非严格模式下，如果传null或undefined，则this指向window；
   /*    "use strict";
    function fn1() {
        console.log(this);
    }
    fn1.call(undefined);*/

    // apply : 传参不同
    // bind : 预处理this；
    /*function fn() {
        console.log(this);
    }
    box.onclick=fn.bind(100);*/


    //  商品排序
    // sort :
    /*var ary = [12.3,55,6,7,8];
    ary.sort(function (a,b) {
        return a-b;
    })*/
    /*var ary = [{c:1},{c:100},{c:30}];
    ary.sort(function (a,b) {
        return a.c-b.c;
    })
    console.log(ary);*/
    var  ary = [{c:1,d:3},{c:100,d:2},{c:30,d:1},{c:1,d:3},{d:2,c:100}];
    // 课下作业：去重； 结合字符串

    // DOM回流，重绘；
    // DOM回流 : 当页面中元素的位置或大小发生改变时，会导致浏览器对其他盒子的位置进行重新计算，这样也是非常消耗性能的，这种现象就是DOM的回流；
    // DOM 重绘: 当盒子的字体颜色，背景，透明度等发生改变，会导致浏览器对元素进行重新描绘；这就是DOM的重绘现象；

    // ajax : 前端和后端交互的一种语法；  async JavaScript and  xml;
    // 1. 4步
    var xhr = new  XMLHttpRequest();
    // 数据绑定：
    //






</script>
</body>
</html>